---
ID: 562
post_title: ""
author: Jonathan Carroll
post_date: 2015-10-17 23:12:50
post_excerpt: ""
layout: post
permalink: http://jcarroll.com.au/?p=562
published: false
---
[swift]
enum ServerResponse {
    case Result(String, String)
    case Error(String)
}
 
let success = ServerResponse.Result(&quot;6:00 am&quot;, &quot;8:09 pm&quot;)
let failure = ServerResponse.Error(&quot;Out of cheese.&quot;)
 
switch success {
case let .Result(sunrise, sunset):
    print(&quot;Sunrise is at \(sunrise) and sunset is at \(sunset).&quot;)
case let .Error(error):
    print(&quot;Failure...  \(error)&quot;)
}
[/swift]


[as3]

//var responseFromServer2: String? // optional, might be nil
//
//// create an overloaded function with a different definition
//// depending on the input structure. Note that function argument
//// names (when more than one) need to be explicitly named on calling
//func servResp(s1: String, s2: String) -&gt; (String, String) {
//    return (s1, s2)
//}
//func servResp(s1: String) -&gt; String {
//    return s1
//}
//func servResp(s1: Int) -&gt; Int {
//    return s1
//}
//
//// create examples of each function. Note that they all have the
//// same name, and thus can now be used as a flexible capture from
//// the server. There is also an exceptional case made available for
//// when unexpected responses arrive.
//let tmpResp1: Any = servResp(&quot;6:00 am&quot;, s2:&quot;8:09 pm&quot;)
//let tmpResp2: Any = servResp(&quot;Out of cheese.&quot;)
//let tmpResp3: Any = servResp(404)
//let tmpResp4: Any = (&quot;This is not expected.&quot;, s2: 503)
//
//// run all of the examples through the switch, but now test on the
//// class of the response rather than a known type
//for testResponse2 in [tmpResp1, tmpResp2, tmpResp3, tmpResp4] {
//    switch testResponse2 {
//    case let (sunrise, sunset) as (String, String):
//        responseFromServer2 = &quot;Sunrise is at \(sunrise) and sunset is at \(sunset).&quot;
//    case let (error) as String:
//        responseFromServer2 = &quot;Failure...  \(error)&quot;
//    case let (errcode) as Int:
//        responseFromServer2 = &quot;Error Code is \(errcode)&quot;
//    default:
//        responseFromServer2 = &quot;Not sure what the response is&quot;
//    }
//
//    print(responseFromServer2!)
//
//}

//// ALTERNATIVE?
//
//var responseFromServer2: String? // optional, might be nil
//
//class serverResponse {
//    // create an overloaded function with a different definition
//    // depending on the input structure. Note that function argument
//    // names (when more than one) need to be explicitly named on calling
//    // Result
//    func servResp(s1: String, s2: String) -&gt; (String, String) {
//        return (s1, s2)
//    }
//    // Fail
//    func servResp(s1: String) -&gt; String {
//        return s1
//    }
//    // ErrorCode
//    func servResp(s1: Int) -&gt; Int {
//        return s1
//    }
//}
//// create examples of each function. Note that they all have the
//// same name, and thus can now be used as a flexible capture from
//// the server.
//let tmpResp1: Any = serverResponse().servResp(&quot;6:00 am&quot;, s2:&quot;8:09 pm&quot;)
//let tmpResp2: Any = serverResponse().servResp(&quot;Out of cheese.&quot;)
//let tmpResp3: Any = serverResponse().servResp(404)
//
//// run all of the examples through the switch, but now test on the
//// class of the response rather than a known type
//for testResponse2 in [tmpResp1, tmpResp2, tmpResp3] {
//    switch testResponse2 {
//    case let (sunrise, sunset) as (String, String):
//        responseFromServer2 = &quot;Sunrise is at \(sunrise) and sunset is at \(sunset).&quot;
//    case let (error) as String:
//        responseFromServer2 = &quot;Failure...  \(error)&quot;
//    case let (errcode) as Int:
//        responseFromServer2 = &quot;Error Code is \(errcode)&quot;
//    default:
//        responseFromServer2 = &quot;Not sure what the response is&quot;
//    }
//
//    print(responseFromServer2!)
//
//}

// ALTERNATIVE?

var responseFromServer2: String? // optional, might be nil

class serverResponse {
    // create an overloaded function with a different definition
    // depending on the input structure. Note that function argument
    // names (when more than one) need to be explicitly named on calling
    // Result
    func servResp(s1: String, s2: String) -&gt; String {
        return &quot;Sunrise is at \(s1) and sunset is at \(s2).&quot;
    }
    // Fail
    func servResp(s1: String) -&gt; String {
        return &quot;Failure...  \(s1)&quot;
    }
    // ErrorCode
    func servResp(s1: Int) -&gt; String {
        return &quot;Error Code is \(s1)&quot;
        
    }
}
// create examples of each function. Note that they all have the
// same name, and thus can now be used as a flexible capture from
// the server.
let tmpResp1 = serverResponse().servResp(&quot;6:00 am&quot;, s2:&quot;8:09 pm&quot;)
let tmpResp2 = serverResponse().servResp(&quot;Out of cheese.&quot;)
let tmpResp3 = serverResponse().servResp(404)

print(tmpResp1)
print(tmpResp2)
print(tmpResp3)

[/as3]